### LR1分析表构造过程：扩展文法 > 项目 ><u>【带向前搜索符】</u>项目集规范族 > 分析表  

-------

先按照LR0的方法将DFA做出来

 ~~~t
G[E]:  S -> BB
	   B -> aB | b
 ~~~

扩展文法:

~~~t
G[E']: S' -> S
	   S  -> BBt
	   B  -> aB
	   B  -> b
~~~

转为I0项目集【用逗号分割前向搜索符】：

- 文法开始集，写Follow集

- 先看前再看后

  ~~~t
  【和Follow集合的求法类似】
  A -> a·Bb, a
  
  ① 当b为空的时候，把“,a”直接抄下来
  ② 当b为非空的时候，把first(b)加入后面
  ~~~

  -----

文法开始集，写Follow集：

~~~t
S' -> ·S	 Follow(S'):{#}
~~~

先看第二条语句S，在点后面紧跟着S的右侧语句只有 S‘ -> S 一条，所以只把在后面跟着的"，#"抄下来

~~~t
S  -> ·BB, #
~~~

再看三四条语句，在点后面紧跟着B的只有 S-> ·BB一条，后面跟着的是B，所以把First(B)加入，First(B) = {a, b}

~~~t
B  -> ·aB, a|b
B  -> ·b,  a|b
~~~

所以构建得到【带向前搜索符的I0】：

~~~t
S' -> ·S,  #
S  -> ·BB, #
B  -> ·aB, a|b
B  -> ·b,  a|b
~~~

之后的方法和LR0一样：

~~~t
I1【S】：
S'-> S·   , #

I2【B】：
S -> B·B  , #
B -> ·aB  , #【此处判断后面跟着的向前搜索符不是从I0获取，而是根据 S -> B·B,# 重新计算】
B -> ·b   , #

I3【a】：
B -> a·B  , a|b
B -> ·aB  , a|b【此处判断后面跟着的向前搜索符不是从I0获取，而是根据 S -> B·B,# 重新计算】
B -> ·b   , a|b	

I4【b】：
B -> b·   , a|b

I5【B】：
S -> BB·  , #

I6【a】: 此状态和I3不一样，因为后面跟着的向前搜索符号不一样
B -> a·B  , #
B -> ·aB  , #
B -> ·b   , #

I7【b】：此状态和I4不一样，因为后面跟着的向前搜索符号不一样
B -> b·   , #

I8【B】:
B -> aB·  , a|b

I9【B】：
B -> aB·  , #
~~~

-----

得到转换图如下：

![image-20230425154554408](.\img\image-20230425154554408.png)

----

按照DFA画LR1分析表【相比于SLR1用FOLLOW集填R，LR1用向前搜索符号填R】：(0行b列少一个S4)

![image-20230425160208195](.\img\image-20230425160208195.png)

---

例1：

~~~t
G[S]: S -> S;B | B
	  B -> BaA | A
	  A -> b(S)
~~~

扩展：

~~~t
I0:   S’-> ·S    , #
	  S -> ·S;B  , #|;
	  S -> ·B    , #|;
	  B -> ·BaA  , #|;|a
	  B -> ·A    , #|;|a
	  A -> ·b(S) , #|;|a
~~~

-----

例2：

~~~t
G[S]: S'-> S
	  S -> A
	  A -> BA
	  A -> ε 【如果遇到空串，则直接用一个·表示】
	  B -> aB
	  B -> b
~~~

得到：

~~~t
I0:  S'-> ·S  , #
     S -> ·A  , # 
     A -> ·BA , #
     A -> ·   , #
     B -> ·aB , a|b|ε 
     B -> ·b  , a|b|ε
~~~

